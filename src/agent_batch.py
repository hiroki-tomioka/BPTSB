import copy
import abc
import itertools
import warnings
import math
import numpy as np

import torch
import torch.nn as nn
import torch.nn.functional as F

from utils import *

warnings.simplefilter("error")


class HardEnvironment(object):
    """A class for the compact bundling of environment parameters"""

    def __init__(
        self,
        gravity=9.81,
        airFriction=0.1,
        ground=False,
        wind=None,
        device=torch.device("cpu"),
    ):
        self.gravity = gravity
        self.airFriction = airFriction
        self.ground = ground
        self.wind = wind
        self.device = device
        self.Fex = torch.zeros((2)).to(self.device)

    def setWind(self, wind):
        self.wind = wind

    def environmentForce(self, morph, state):
        """Calculate forces generated by the environment returns Vector Fenv asks a morphology and a state"""
        fair = -self.airFriction * state.speed
        fgravy = -self.gravity * morph.mass  # ground friction force
        fenv = fair
        fenv.y = fair.y + fgravy
        return fenv

    def windForce(self, morph):
        """Set wind strength"""
        xFwind = torch.ones((morph.noNodes)).to(self.device) * self.wind
        yFwind = torch.ones((morph.noNodes)).to(self.device)
        return SpaceListBatch(xFwind, yFwind)

    def externalForce(self, morph, brain, us, inputLayer, noise):
        """Set external force"""
        if torch.all(us == 0):  ## MNIST
            self.Fex = torch.zeros((morph.batchSize, 2, morph.noNodes)).to(self.device)
        else:
            if brain:
                raise NotImplementedError
            else:  ## time-serires
                self.Fex = us.view(-1, 1, 1) * inputLayer
            if (morph.shape == "DoubleCircles") or (morph.shape == "MultiCircles"):
                self.Fex[:, :, -1] = 0
        return SpaceListBatch(self.Fex)


class Morphology(object):
    __metaclass__ = abc.ABCMeta
    """ An abstract class for the compact bundling of morphological parameters"""

    def __init__(
        self,
        initialPos,
        connections,
        noNodes,
        mass,
        environment,
        deltaInitialPos=None,
        seed=None,
        device=torch.device("cpu"),
    ):
        # init agent
        self.noNodes = noNodes  # the number of nodes the agent consists of
        self.environment = environment
        self.initialPos = initialPos
        self.connections = connections
        self.deltaInitialPos = deltaInitialPos
        self.seed = seed
        self.device = device
        self.connections_tensor = torch.tensor(self.connections).to(self.device)
        self.fex_history = None

        # set initial masses
        if isCallable(mass):
            self.mass = mass((self.noNodes,))
        else:
            self.mass = mass * torch.ones((self.noNodes,)).to(self.device)

    def set_binaryNodes(self, binaryNodes):
        self.binaryNodes = binaryNodes

    def connectionParameterMatrix(self, parameter, mask=None):
        if mask is None:
            if isCallable(parameter):
                matrix = parameter((self.noNodes, self.noNodes)) * self.connections
                matrix = torch.tril(matrix) + torch.tril(matrix).T  # ensure symmetry
            else:
                matrix = (
                    parameter
                    * torch.ones((self.noNodes, self.noNodes))
                    * self.connections
                )
        else:
            if isCallable(parameter):
                matrix = parameter((self.noNodes, self.noNodes)) * self.connections
                matrix = (
                    torch.tril(matrix) + torch.tril(matrix).T * mask
                )  # ensure symmetry
            else:
                matrix = (
                    parameter
                    * torch.ones((self.noNodes, self.noNodes))
                    * self.connections
                    * mask
                )
        return matrix

    @abc.abstractmethod
    def _connectionForce(self, state, modulatedRestLength):
        """Return the force resulting of a connection"""

    def force(
        self,
        brain,
        state,
        modulatedRestLength,
        us,
        inputLayer,
        noise,
    ):
        """Calculate the force acting on the nodes"""
        fspring = self._connectionForce(state, modulatedRestLength)
        if (inputLayer.shape[1] == self.binaryNodes.shape[0]) or (
            inputLayer.shape[1] == self.binaryNodes.shape[0] * 2
        ):
            _inputLayer = inputLayer
        else:
            _inputLayer = inputLayer.view(inputLayer.shape[0], 2, -1)[:, 1]
        fex = self.environment.externalForce(self, brain, us, _inputLayer, noise)
        if self.fex_history is not None:
            self.fex_history.append(fex.matrix)
        if self.environment.ground:
            # environment force
            fenv = self.environment.environmentForce(self, state)
            return fspring + fex + fenv
        elif self.environment.wind is not None:
            fwind = self.environment.windForce(self)
            return fspring + fex + fwind
        else:
            return fspring + fex

    def SymmetricMatrix(self, mat):
        if type(mat) == torch.Tensor:
            if not mat.is_cuda:
                mat = mat.to(self.device)
            if mat.ndim == 3:
                mat = (
                    (mat + torch.permute(mat, (0, 2, 1)))
                    / 2
                    * torch.tensor(self.connections).to(self.device)
                )
            elif mat.ndim == 2:
                mat = (mat + mat.T) / 2 * torch.tensor(self.connections).to(self.device)
            return mat.to(self.device)
        else:
            raise NotImplementedError


class SpringMorphology(Morphology):
    """Morphology consisting of linear springs"""

    def __init__(
        self,
        noNodes=20,
        mass=1,
        initialHeight=4,
        noNeighbours=3,
        environment=HardEnvironment(),
        shape="DoubleCircles",
        initSize=4,
        deltaPos=0.3,
        seed=None,
        noisedLength=False,
        batchSize=1,
        device=torch.device("cpu"),
    ):

        self.initialHeight = initialHeight  # height of the agent
        self.noNeighbours = noNeighbours  # number of Neighbours
        self.environment = environment
        self.shape = shape
        self.device = device
        self.initSize = initSize
        self.batchSize = batchSize
        self.eye = torch.eye(noNodes).to(self.device)
        if shape == "DoubleCircles":
            initialPos = self.generateShapeDoubleCircles(noNodes, self.initSize)
            connections = self.generateConnectionsDoubleCircles(noNodes)
        elif shape == "MultiCircles":
            initialPos = self.generateShapeMultiCircles(noNodes, self.initSize)
            connections = self.generateConnectionsMultiCircles(noNodes)
        if deltaPos is not None:
            deltaInitialPos = self.generateDeltaInitialPos(initialPos, deltaPos)
        else:
            deltaInitialPos = None
        super(SpringMorphology, self).__init__(
            initialPos,
            connections,
            noNodes=noNodes,
            mass=mass,
            environment=environment,
            deltaInitialPos=deltaInitialPos,
            seed=seed,
            device=device,
        )

        if seed is not None:
            torch.manual_seed(seed)
        if noNodes < 50:
            self.spring, self.damping = self.setRandomPhysicalParams(
                1.0, 100.0, 0, 10.0
            )
        else:
            self.spring, self.damping = self.setRandomPhysicalParams(1.0, 100.0, 0, 5.0)

        # set rest length
        self.restLength = self.getRestLength(initialPos, connections, noisedLength)
        self.noComps = np.nonzero(np.triu(self.connections))[0].shape[0]

    def specifyInitSize(self, size):
        self.initSize = size

    def specifyPhysicalParams(self, spring, damping):
        self.spring = spring
        self.damping = damping

    def resetMorph(self, size, spring, damping, restLength=None):
        self.specifyInitSize(size)
        self.specifyPhysicalParams(spring, damping)
        if self.shape == "DoubleCircles":
            initialPos = self.generateShapeDoubleCircles(self.noNodes, self.initSize)
            connections = self.generateConnectionsDoubleCircles(self.noNodes)
        elif self.shape == "MultiCircles":
            initialPos = self.generateShapeMultiCircles(self.noNodes, self.initSize)
            connections = self.generateConnectionsMultiCircles(self.noNodes)
        if restLength is not None:
            self.restLength = restLength
        super(SpringMorphology, self).__init__(
            initialPos,
            connections,
            noNodes=self.noNodes,
            mass=self.mass,
            environment=self.environment,
        )

    def setRandomPhysicalParams(self, springMin, springMax, dampingMin, dampingMax):
        spring = (springMax - springMin) * torch.rand(
            self.connections.shape[0], self.connections.shape[1]
        ) + springMin
        spring = (spring + spring.t()) / 2 * self.connections
        spring = self.SymmetricMatrix(spring)
        damping = (dampingMax - dampingMin) * torch.rand(
            self.connections.shape[0], self.connections.shape[1]
        ) + dampingMin
        damping = (damping + damping.t()) / 2 * self.connections
        damping = self.SymmetricMatrix(damping)
        return spring.to(self.device), damping.to(self.device)

    def setSamePhysicalParams(self, springVal, dampingVal):
        spring = (
            torch.full(
                (self.connections.shape[0], self.connections.shape[1]), springVal
            )
            * self.connections
        )
        damping = (
            torch.full(
                (self.connections.shape[0], self.connections.shape[1]), dampingVal
            )
            * self.connections
        )
        return spring.to(self.device), damping.to(self.device)

    def _connectionForce(self, state, modulatedRestLength):
        """Calculate the forces acting due to the springs, return x,y spring force"""
        difx, dify = state.pos.getDifference()
        difxy = torch.sqrt(difx**2 + dify**2 + 1e-16) + torch.eye(self.noNodes).to(
            self.device
        )  # Otherwise divide by zero

        # Normal Linear Spring Definition
        fConnectionx_spring = -torch.sum(
            self.spring * difx * (1 - modulatedRestLength / difxy), axis=2
        )
        fConnectiony_spring = -torch.sum(
            self.spring * dify * (1 - modulatedRestLength / difxy), axis=2
        )

        # damping forces
        difvx, difvy = state.speed.getDifference()
        fConnectionx_damping = -torch.sum(self.damping * difvx, axis=2)
        fConnectiony_damping = -torch.sum(self.damping * difvy, axis=2)

        fConnectionx = fConnectionx_spring + fConnectionx_damping
        fConnectiony = fConnectiony_spring + fConnectiony_damping

        return SpaceListBatch(fConnectionx, fConnectiony)

    def getRestLength(self, initialPos, connections, noisedLength):
        difx, dify = initialPos.getDifference()
        if difx.ndim == 3:
            difx = difx[0]
            dify = dify[0]
        restLength = torch.sqrt(difx**2 + dify**2 + 1e-16) * torch.tensor(
            connections
        ).to(self.device)
        if noisedLength:
            noiseMatrix = (torch.rand(self.noNodes, self.noNodes) * 0.4 + 0.8).to(
                self.device
            )
            restLength = restLength * noiseMatrix
        restLength = self.SymmetricMatrix(restLength)
        return restLength

    def generateShapeDoubleCircles(self, noNodes, initSize):
        assert noNodes % 2 == 1
        nodeIds = torch.arange(noNodes).to(self.device)
        outerRadius = initSize / 2
        innerRadius = initSize / 4
        xPos0 = (
            torch.sin(
                nodeIds[: int((noNodes - 1) / 2)]
                * 2
                * np.pi
                / torch.max(nodeIds[: int((noNodes - 1) / 2)] + 1)
            )
            * outerRadius
        )
        xPos1 = (
            torch.sin(
                (nodeIds[: int((noNodes - 1) / 2)] + 0.5)
                * 2
                * np.pi
                / torch.max(nodeIds[: int((noNodes - 1) / 2)] + 1)
            )
            * innerRadius
        )
        xPos2 = torch.tensor([0]).to(self.device)
        xPos = torch.cat((xPos0, xPos1, xPos2))
        yPos0 = (
            torch.cos(
                nodeIds[: int((noNodes - 1) / 2)]
                * 2
                * np.pi
                / torch.max(nodeIds[: int((noNodes - 1) / 2)] + 1)
            )
            * outerRadius
        )
        yPos1 = (
            torch.cos(
                (nodeIds[: int((noNodes - 1) / 2)] + 0.5)
                * 2
                * np.pi
                / torch.max(nodeIds[: int((noNodes - 1) / 2)] + 1)
            )
            * innerRadius
        )
        yPos2 = torch.tensor([0]).to(self.device)
        yPos = torch.cat((yPos0, yPos1, yPos2))
        xPoss = [xPos for _ in range(self.batchSize)]
        yPoss = [yPos for _ in range(self.batchSize)]
        xPos = torch.stack(xPoss, 0)
        yPos = torch.stack(yPoss, 0)
        initialPos = SpaceListBatch(xPos.to(self.device), yPos.to(self.device))
        return initialPos

    def generateShapeMultiCircles(self, noNodes, initSize):
        assert noNodes % 2 == 1
        circleNum = int(math.sqrt(noNodes - 1) / 2)
        noNodesList = [(2 * (circleNum - i) - 1) * 4 for i in range(circleNum)]
        radiusList = [
            initSize / 2 / circleNum * (circleNum - i) for i in range(circleNum)
        ]
        nodeIds = torch.arange(noNodes).to(self.device)
        xPosList, yPosList = [], []
        firstIndex = 0
        for i in range(circleNum):
            nodes_in_circle = nodeIds[firstIndex : firstIndex + noNodesList[i]]
            if i % 2 == 0:
                _xPos = (
                    torch.sin(
                        nodes_in_circle * 2 * np.pi / torch.max(nodes_in_circle + 1)
                    )
                    * radiusList[i]
                )
                _yPos = (
                    torch.cos(
                        nodes_in_circle * 2 * np.pi / torch.max(nodes_in_circle + 1)
                    )
                    * radiusList[i]
                )
            else:
                _xPos = (
                    torch.sin(
                        (nodes_in_circle + 0.5)
                        * 2
                        * np.pi
                        / torch.max(nodes_in_circle + 1)
                    )
                    * radiusList[i]
                )
                _yPos = (
                    torch.cos(
                        (nodes_in_circle + 0.5)
                        * 2
                        * np.pi
                        / torch.max(nodes_in_circle + 1)
                    )
                    * radiusList[i]
                )
            xPosList.append(_xPos.to(self.device))
            yPosList.append(_yPos.to(self.device))
        xPosList.append(torch.tensor([0]).to(self.device))
        yPosList.append(torch.tensor([0]).to(self.device))
        xPos = torch.cat(xPosList)
        yPos = torch.cat(yPosList)
        xPoss = [xPos for _ in range(self.batchSize)]
        yPoss = [yPos for _ in range(self.batchSize)]
        xPos = torch.stack(xPoss, 0)
        yPos = torch.stack(yPoss, 0)
        initialPos = SpaceListBatch(xPos.to(self.device), yPos.to(self.device))
        return initialPos

    def generateConnectionsDoubleCircles(self, noNodes):
        ## initialise connections ##
        # generate the connection matrix
        assert noNodes % 2 == 1
        connections = np.zeros((noNodes, noNodes))
        for i in range(int((noNodes - 1) / 2)):
            if i == 0:
                connections[i, int((noNodes - 1) / 2) + i] = connections[
                    i, noNodes - 2
                ] = 1
            else:
                connections[i, int((noNodes - 1) / 2) + i - 1] = connections[
                    i, int((noNodes - 1) / 2) + i
                ] = 1
        for i in range(int((noNodes - 1) / 2), noNodes - 1):
            if i == int((noNodes - 1) / 2):
                connections[i, i + 1] = connections[i, noNodes - 2] = connections[
                    i, noNodes - 1
                ] = 1
            else:
                connections[i, i + 1] = connections[i, noNodes - 1] = 1
        connections += connections.T
        return connections

    def generateConnectionsMultiCircles(self, noNodes):
        ## initialise connections ##
        # generate the connection matrix
        circleNum = int(math.sqrt(noNodes - 1) / 2)
        noNodesList = [(2 * (circleNum - i) - 1) * 4 for i in range(circleNum)]
        connections = np.zeros((noNodes, noNodes))
        _step = int((circleNum * 2 - 4) / 2)

        for i in range(circleNum - 1):
            if i == 0:
                outerIndexes = [j for j in range(noNodesList[i])]
            else:
                outerIndexes = [j + sum(noNodesList[:i]) for j in range(noNodesList[i])]
            innerIndexes = [
                j + sum(noNodesList[: i + 1]) for j in range(noNodesList[i + 1])
            ]
            _currentOuterNode, _currentInnerNode = outerIndexes[0], innerIndexes[0]
            if i != 0:
                for j in outerIndexes[:-1]:
                    connections[j, j + 1] = 1
                connections[outerIndexes[-1], outerIndexes[0]] = 1
            for _ in range(4):
                for j in range(_step):
                    connections[_currentOuterNode + j, _currentInnerNode + j] = 1
                _currentOuterNode += _step
                _currentInnerNode += _step
                for j in range(3):
                    connections[_currentOuterNode + j, _currentInnerNode] = 1
                _currentOuterNode += 3
                _currentInnerNode += 1
                for j in range(_step):
                    connections[_currentOuterNode + j, _currentInnerNode + j] = 1
                _currentOuterNode += _step
                _currentInnerNode += _step
            _step -= 1
        outerIndexes = [j + sum(noNodesList[:-1]) for j in range(noNodesList[-1])]
        for j in outerIndexes[:-1]:
            connections[j, j + 1] = 1
            connections[j, -1] = 1
        connections[outerIndexes[-1], outerIndexes[0]] = connections[
            outerIndexes[-1], -1
        ] = 1

        connections += connections.T
        connections = np.where(connections > 1, 1, connections)
        return connections

    def generateDeltaInitialPos(self, initialPos, deltaPos):
        deltaMatrix = SpaceListBatch(deltaPos)
        deltaInitialPos = initialPos.copy() + deltaMatrix
        return deltaInitialPos


class AgentState(object):
    """A class for the compact bundling of the state of an Agent"""

    def __init__(
        self,
        currentTime=0,
        morph=None,
        copyState=0,
        centerFlag=False,
        savePosType="tensor",
        device=torch.device("cpu"),
    ):
        self.centerFlag = centerFlag
        self.device = device
        if copyState == 0:
            self.currentTime = currentTime
            self.pos = SpaceListBatch.copy(morph.initialPos)
            self.shape = self.pos.shape
            self.speed = SpaceListBatch(torch.zeros((self.shape)).to(self.device))
        elif copyState == 1:
            self.currentTime = currentTime
            self.pos = SpaceListBatch.copy(morph.deltaInitialPos)
            self.shape = self.pos.shape
            self.speed = SpaceListBatch(torch.zeros((self.shape)).to(self.device))
        else:
            self.currentTime = copyState.currentTime
            self.pos = copyState.pos.copy()
            self.shape = self.pos.shape
            self.speed = copyState.speed.copy()
        self.savePosType = savePosType
        self.movableNodes_history = []
        self.pos_history = []
        self.centerNode_history = []

        self.movableNodes = None

    def resetState(self, morph):
        self.currentTime = 0.0
        if morph is not None:
            self.pos = SpaceListBatch.copy(morph.initialPos)
            self.shape = self.pos.shape
            self.speed = SpaceListBatch(torch.zeros((self.shape)).to(self.device))
        self.movableNodes_history = []
        self.pos_history = []
        self.centerNode_history = []

    def resetSavePosType(self, savePosType):
        self.savePosType = savePosType
        self.movableNodes_history = []
        self.pos_history = []
        self.centerNode_history = []

    def copy(self):
        """Create a copy of the current state so this copy will not change"""
        return AgentState(
            copyState=self,
            centerFlag=self.centerFlag,
            savePosType=self.savePosType,
            device=self.device,
        )

    def changeState(self, addt, addpos, addspeed, ground=False):
        """Add time and add Vectors to the current positions and speed"""
        for inputValue in [addpos, addspeed]:
            assert self.shape == np.shape(inputValue), "wrong shape of input arguments"
        self.pos += addpos
        self.speed += addspeed
        self.currentTime = round(self.currentTime + addt, 2)
        if ground:
            self.pos.ground(self.speed)

    def addPos(self, addt, addpos, ground=False):
        assert self.shape == np.shape(addpos), "wrong shape of input arguments"
        self.pos += addpos
        self.currentTime = round(self.currentTime + addt, 2)
        if ground:
            self.pos.ground(self.speed)

    def addSpeed(self, addspeed, ground=False):
        assert self.shape == np.shape(addspeed), "wrong shape of input arguments"
        self.speed += addspeed
        if ground:
            self.pos.ground(self.speed)

    def savePos(self, tau, simStep):
        if self.savePosType == "tensor":
            if simStep % tau == tau - 1:
                movableNodesPos = torch.stack(
                    [
                        self.pos.x.gather(1, self.movableNodes),
                        self.pos.y.gather(1, self.movableNodes),
                    ],
                    dim=1,
                )
                self.movableNodes_history.append(movableNodesPos)
            if self.centerFlag:
                centerNodePos = torch.stack(
                    [
                        self.pos.x[-1],
                        self.pos.y[-1],
                        self.speed.x[-1],
                        self.speed.y[-1],
                    ],
                    dim=1,
                )
                self.centerNode_history.append(centerNodePos)
            allNodesPos = torch.stack([self.pos.x, self.pos.y], dim=0)
            self.pos_history.append(allNodesPos)
        else:
            raise NotImplementedError

    def resetCurrentTime(self):
        self.currentTime = 0


class Control(object):
    __metaclass__ = abc.ABCMeta
    """An abstract class for the compact bundling of control parameters"""

    @abc.abstractmethod
    def modulationFactor(self, agentState, brain):
        """Must return array with modulation factors"""


class TimeControl(Control):
    __metaclass__ = abc.ABCMeta
    """Abstract class with control signals only based on time """

    @abc.abstractmethod
    def modulationFactorTime(self, time, brain):
        """Must return array with modulation factors"""

    def modulationFactor(self, agentState, brain):
        return self.modulationFactorTime(agentState.currentTime, brain)


class NoControl(TimeControl):
    """Specific instance of Control Class"""

    def __init__(
        self, morph, simTime, simTimeStep, tau, batchSize=1, device=torch.device("cpu")
    ):
        super(NoControl, self).__init__()
        self.simTimeStep = simTimeStep
        self.simulLen = round(simTime / simTimeStep)
        self.trainLen = round(self.simulLen * 3 / 5 / tau) * tau
        self.testLen = round(self.simulLen / 5 / tau) * tau
        self.washoutLen = self.simulLen - self.trainLen - self.testLen
        self.tau = tau
        self.charSize, self.timeScale = None, None
        self.batchSize = batchSize
        self.device = device

    def setSimTime(self, simTime, simTimeStep, tau):
        self.simTimeStep = simTimeStep
        self.tau = tau
        self.simulLen = round(simTime / self.simTimeStep)
        self.trainLen = round(self.simulLen * 3 / 5 / self.tau) * self.tau
        self.testLen = round(self.simulLen / 5 / self.tau) * self.tau
        self.washoutLen = self.simulLen - self.trainLen - self.testLen

    def generateMNISTtimeseries(self, inputScale=0, pixelNum=28):
        if inputScale != 0:
            raise NotImplementedError
        else:
            self.us = torch.zeros(
                self.batchSize, int(self.simulLen), int(pixelNum**2)
            ).to(self.device)
            self.inputScale = inputScale

    def modulationFactorTime(self, time, brain):
        """Return rest length modulation factor"""
        return 1


class SineControl(NoControl):
    """Specific instance of Control Class with sines, works on spring morphologies"""

    uniform2pi = lambda shape: torch.distributions.Uniform(0, 2 * np.pi).sample(shape)

    def __init__(
        self,
        morph,
        simTime,
        simTimeStep,
        tau,
        device=torch.device("cpu"),
        amplitude=0.2,
        phase=uniform2pi,
        omega=2 * np.pi,
        generatorNum=1,
    ):
        super(SineControl, self).__init__(morph, simTime, simTimeStep, tau, device)

        ## initialise modulation paramters ##
        if generatorNum[0] < 0:
            generatorMask = None
        else:
            generatorMask = torch.zeros((morph.noNodes, morph.noNodes))
            _connections = np.triu(morph.connections)
            compNum = 0
            for i, j in itertools.product(
                range(_connections.shape[0]), range(_connections.shape[1])
            ):
                if _connections[i, j]:
                    if compNum in generatorNum:
                        generatorMask[i, j] = 2
                    compNum += 1
            generatorMask = morph.SymmetricMatrix(generatorMask)
        self.amplitude = morph.connectionParameterMatrix(amplitude, generatorMask)
        self.phase = morph.connectionParameterMatrix(phase, generatorMask)
        self.omega = morph.connectionParameterMatrix(omega, generatorMask)

        self.feedback = False

    def modulationFactorTime(self, time, brain):
        """Return rest length modulation factor"""
        if self.feedback:
            return (
                1
                + self.amplitude * torch.sin(self.omega * time + self.phase)
                + self.feedbackFactor
            )
        else:
            return 1 + self.amplitude * torch.sin(self.omega * time + self.phase)


class FreeControl(NoControl):
    """Specific instance of Control Class"""

    uniform2pi = lambda shape: torch.distributions.Uniform(0, 2 * np.pi).sample(shape)

    def __init__(
        self,
        morph,
        simTime,
        simTimeStep,
        tau,
        device=torch.device("cpu"),
        amplitude=0.2,
        phase=uniform2pi,
        omega=2 * np.pi,
        generatorNum=1,
    ):
        super(FreeControl, self).__init__(morph, simTime, simTimeStep, tau, device)

        ## initialise modulation paramters ##
        if generatorNum[0] < 0:
            generatorMask = None
        else:
            generatorMask = torch.zeros((morph.noNodes, morph.noNodes))
            for num in generatorNum:
                generatorIndex = torch.nonzero(torch.from_numpy(morph.connections))[
                    num, :
                ]
                generatorMask[generatorIndex[0], generatorIndex[1]] = generatorMask[
                    generatorIndex[1], generatorIndex[0]
                ] = 1
        self.amplitude = morph.connectionParameterMatrix(amplitude, generatorMask)
        self.phase = morph.connectionParameterMatrix(phase, generatorMask)
        self.omega = morph.connectionParameterMatrix(omega, generatorMask)
        self.morph = morph
        self.generatorMask = generatorMask

        self.base_omega = copy.copy(np.matrix([omega]))

    def modulationFactorTime(self, time, brain):
        """Return rest length modulation factor"""
        newLengths = brain(self.us.unsqueeze(0).to(torch.float64) * 20)
        modulationFac = torch.zeros((self.morph.noNodes, self.morph.noNodes))
        for i, (x, y) in enumerate(
            zip(
                np.nonzero(self.morph.connections)[0],
                np.nonzero(self.morph.connections)[1],
            )
        ):
            modulationFac[x][y] = newLengths[0, i]
        modulationFac = (modulationFac + modulationFac.T) / 2
        if self.generatorMask is not None:
            modulationFac = modulationFac * self.generatorMask
        return 1 + self.amplitude * torch.sin(modulationFac)


class BrainMLP(nn.Module):
    def __init__(self, inputDim, outputDim):
        super(BrainMLP, self).__init__()
        if inputDim > 100:
            self.fc1 = nn.Linear(inputDim, inputDim * 2, dtype=torch.float64)
            self.fc2 = nn.Linear(inputDim * 2, inputDim, dtype=torch.float64)
            self.fc3 = nn.Linear(inputDim, outputDim, dtype=torch.float64)
            torch.nn.init.xavier_normal_(self.fc1.weight, gain=1)
            torch.nn.init.xavier_normal_(self.fc2.weight, gain=1)
            torch.nn.init.xavier_normal_(self.fc3.weight, gain=1)
        else:
            self.fc1 = nn.Linear(inputDim, 128, dtype=torch.float64)
            self.fc2 = nn.Linear(128, 128, dtype=torch.float64)
            self.fc3 = nn.Linear(128, outputDim, dtype=torch.float64)
            torch.nn.init.xavier_normal_(self.fc1.weight, gain=2.7)
            torch.nn.init.xavier_normal_(self.fc2.weight, gain=2.7)
            torch.nn.init.xavier_normal_(self.fc3.weight, gain=2.7)

    def forward(self, x):
        x = F.relu(self.fc1(x))
        x = F.relu(self.fc2(x))
        x = self.fc3(x)
        return x


class BrainCNN(nn.Module):
    def __init__(self, outputDim):
        super(BrainCNN, self).__init__()
        self.conv1 = nn.Conv2d(1, 16, 3, dtype=torch.float64)
        self.conv2 = nn.Conv2d(16, 32, 3, dtype=torch.float64)
        self.pool = nn.MaxPool2d(2, stride=2)
        self.fc = nn.Linear(32 * 5 * 5, outputDim, dtype=torch.float64)
        torch.nn.init.xavier_normal_(self.fc.weight, gain=1)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        x = self.pool(x)
        x = F.relu(self.conv2(x))
        x = self.pool(x)
        x = x.view(-1, 32 * 5 * 5)
        x = self.fc(x)
        return x


class Agent(object):
    """A class for the compact bundling of the morphology, control system and state of the agent"""

    def __init__(
        self,
        morph,
        control,
        state=None,
        deltaPos=None,
        seed=None,
        readoutDim=1,
        centerFlag=False,
        centralPointOutput=False,
        savePosType="tensor",
        pixXpix=25,
        brain="LIL",
        closedloop=False,
        fixedExternalForce=None,
        noise=0,
        device=torch.device("cpu"),
    ):
        self.morph = morph
        self.control = control
        self.centerFlag = centerFlag
        self.savePosType = savePosType
        if state is not None:
            self.state = state
        elif deltaPos is not None:
            self.state = AgentState(
                currentTime=0,
                morph=morph,
                copyState=1,
                centerFlag=self.centerFlag,
                savePosType=self.savePosType,
                device=device,
            )
        else:
            self.state = AgentState(
                currentTime=0,
                morph=morph,
                centerFlag=self.centerFlag,
                savePosType=self.savePosType,
                device=device,
            )
        self.seed = seed
        self.brain = None
        self.device = device
        self.optimizer_ridge = Ridge_opt(beta=1e-9, device=self.device)
        self.preSimStep = None
        if self.morph.shape == "DoubleCircles":
            self.fixedNodes = [i for i in range(int((self.morph.noNodes - 1) / 2))]
        elif self.morph.shape == "MultiCircles":
            circleNum = int(math.sqrt(self.morph.noNodes - 1) / 2)
            self.fixedNodes = [i for i in range((2 * circleNum - 1) * 4)]
        del_list = lambda items, indexes: [
            item for index, item in enumerate(items) if index not in indexes
        ]
        allNodes = [i for i in range(self.morph.noNodes)]
        _movableNodes = torch.tensor(del_list(allNodes, self.fixedNodes)).to(
            self.device
        )
        self.movableNodes = torch.stack(
            [_movableNodes for _ in range(self.morph.batchSize)], 0
        )
        self.state.movableNodes = self.movableNodes
        self.centralPointOutput = centralPointOutput
        if centralPointOutput:
            self.reservoirStatesDim = 2
        else:
            self.reservoirStatesDim = self.movableNodes.shape[-1] * 2
        self.binaryNodes = torch.tensor(
            [0 if i in self.fixedNodes else 1 for i in range(self.morph.noNodes)]
        ).to(self.device)
        self.morph.set_binaryNodes(self.binaryNodes)
        self.closedloop = closedloop
        self.fixedExternalForce = fixedExternalForce
        self.noise = noise
        if self.seed is not None:
            torch.manual_seed(self.seed)
        if brain == "MLP":
            self.inputLayer = torch.normal(
                mean=0, std=0.01, size=(self.morph.noNodes * 2, self.morph.noNodes * 2)
            ).to(self.device)
            self.brain = BrainMLP(pixXpix, self.morph.noNodes * 2).to(self.device)
        elif brain == "CNN":
            self.inputLayer = torch.normal(
                mean=0, std=0.01, size=(self.morph.noNodes * 2, self.morph.noNodes * 2)
            ).to(self.device)
            self.brain = BrainCNN(self.morph.noNodes * 2).to(self.device)
        else:
            self.inputLayer = torch.normal(
                mean=0,
                std=0.01,
                size=(pixXpix, self.morph.noNodes * 2),
                dtype=torch.float64,
            ).to(self.device)
        self.readoutDim = readoutDim
        self.readoutLayer = torch.normal(
            mean=0,
            std=1,
            size=(self.reservoirStatesDim + 1, self.readoutDim),
            dtype=torch.float64,
        ).to(self.device)

    def setBatchSize(self, batchSize):
        self.morph.batchSize = batchSize
        self.control.batchSize = batchSize
        del_list = lambda items, indexes: [
            item for index, item in enumerate(items) if index not in indexes
        ]
        allNodes = [i for i in range(self.morph.noNodes)]
        _movableNodes = torch.tensor(del_list(allNodes, self.fixedNodes)).to(
            self.device
        )
        self.movableNodes = torch.stack([_movableNodes for _ in range(batchSize)], 0)
        self.state.movableNodes = self.movableNodes

    def setFixedExternalForce(self, val):
        self.fixedExternalForce = val

    def normalReadoutLayer(self, dim, seed):
        if seed is not None:
            torch.manual_seed(seed)
        self.reservoirStatesDim = dim
        self.readoutLayer = torch.normal(
            mean=0, std=1, size=(dim + 1, self.readoutDim), dtype=torch.float64
        ).to(self.device)

    def resetAgent(self, morph=None):
        self.state.resetCurrentTime()
        self.resetOptimizer()
        if morph is not None:
            self.morph = morph
        self.state.resetState(morph)
        self.morph.fex_history = None

    def resetOptimizer(self):
        self.optimizer_ridge = Ridge_opt(beta=1e-9, device=self.device)

    def setdeltaPos(self, deltaPos):
        if self.morph.shape == "MultiCircles":
            initialPos = self.morph.generateShapeMultiCircles(
                self.morph.noNodes, self.morph.initSize
            )
            self.morph.deltaInitialPos = self.morph.generateDeltaInitialPos(
                initialPos, deltaPos
            )
            self.state = AgentState(
                currentTime=0,
                morph=self.morph,
                copyState=1,
                centerFlag=self.centerFlag,
                savePosType=self.savePosType,
                device=self.device,
            )
            self.state.movableNodes = self.movableNodes
        elif self.morph.shape == "DoubleCircles":
            initialPos = self.morph.generateShapeDoubleCircles(
                self.morph.noNodes, self.morph.initSize
            )
            self.morph.deltaInitialPos = self.morph.generateDeltaInitialPos(
                initialPos, deltaPos
            )
            self.state = AgentState(
                currentTime=0,
                morph=self.morph,
                copyState=1,
                centerFlag=self.centerFlag,
                savePosType=self.savePosType,
                device=self.device,
            )
            self.state.movableNodes = self.movableNodes

    def computeForces(self, simStep):
        ## Forces
        # modulated rest lengths
        modulatedRestLength = self.morph.restLength * self.control.modulationFactor(
            self.state, self.brain
        )
        if self.control.us.shape[-1] == self.control.simulLen:
            f = self.morph.force(
                self.brain,
                self.state,
                modulatedRestLength,
                self.control.us[:, simStep],
                self.inputLayer,
                self.noise,
            )
        else:
            f = self.morph.force(
                self.brain,
                self.state,
                modulatedRestLength,
                self.control.us,
                self.inputLayer,
                self.noise,
            )
        return f

    def computeAcceleration(self, simStep):
        """Compute acceleration, returns Acceleration Vector"""
        f = self.computeForces(simStep)
        a = f / self.morph.mass
        return a

    def getVelocity(self):
        return self.state.speed

    def getState(self):
        return self.state.copy()

    def changeState(self, timeStep, V, A):
        """Change the time and positions based on time derivatives"""

        posChange = timeStep * V
        speedChange = A * timeStep
        self.state.changeState(
            timeStep, posChange, speedChange, self.morph.environment.ground
        )
        self.state.savePos()

    def changeStateVerlet(self, timeStep, V, Aold, tau=10, noise=0, impulsenoise=None):
        simStep = round(self.state.currentTime * 100)

        if noise != 0:
            shape = np.shape(V.matrix)
            posNoise = 1 + np.random.standard_normal(shape) * noise
            speedNoise = 1 + np.random.standard_normal(shape) * noise

        posChange = timeStep * V + (timeStep * timeStep) * Aold / 2
        posChange.x = posChange.x * self.binaryNodes
        posChange.y = posChange.y * self.binaryNodes

        if noise != 0:
            posChange *= posNoise
        self.state.addPos(timeStep, posChange, self.morph.environment.ground)
        self.state.savePos(tau, simStep)
        Anew = self.computeAcceleration(simStep)

        if impulsenoise is not None:
            Anew = Anew + SpaceListBatch(impulsenoise)

        # then Force calculation
        # then Speed update
        speedChange = timeStep * (Aold + Anew) / 2
        speedChange.x = speedChange.x * self.binaryNodes
        speedChange.y = speedChange.y * self.binaryNodes
        if noise != 0:
            speedChange *= speedNoise
        self.state.addSpeed(speedChange, self.morph.environment.ground)

        return Anew

    def addData(self, tau, simStep):
        control = self.control
        if self.centralPointOutput:
            reservoirStates = torch.cat(
                (self.state.pos.x[-1].unsqueeze(0), self.state.pos.y[-1].unsqueeze(0))
            )
        else:
            reservoirStates = torch.cat(
                (
                    torch.flatten(self.state.pos.x).gather(0, self.movableNodes),
                    torch.flatten(self.state.pos.y).gather(0, self.movableNodes),
                )
            )
        if simStep < control.washoutLen:
            pass
        elif (
            (simStep >= control.washoutLen)
            and (simStep < control.washoutLen + control.trainLen)
            and (simStep > self.preSimStep)
        ):
            self.optimizer_ridge.add_data(
                reservoirStates,
                control.target[round((self.state.currentTime * 100 - 1) // tau)],
            )
        elif (simStep >= control.washoutLen + control.trainLen) and (
            simStep > self.preSimStep
        ):
            self.optimizer_ridge.add_data(
                reservoirStates,
                control.target[round((self.state.currentTime * 100 - 1) // tau)],
                test=True,
            )
        self.preSimStep = simStep

    def printState(self):

        if self.morph.environment.wind is None:
            stateDescription = f"external force: {round(self.fixedExternalForce, 2)}"
        else:
            if self.morph.environment.wind > 0:
                arrow = "-" * int(self.morph.environment.wind / 15 * 10) + ">"

            elif self.morph.environment.wind < 0:
                arrow = "<" + "-" * int(-self.morph.environment.wind / 15 * 10)
            else:
                arrow = ""
            stateDescription = (
                f"wind: {round(self.morph.environment.wind/15, 2)}\n{arrow}"
            )
        return stateDescription

    def _getAgentPos2D(self):
        """Get the x and y coordinates of the nodes and the connections matrix"""
        return self.state.pos.x, self.state.pos.y, self.morph.connections

    def reset(self):

        self.state = AgentState(
            0,
            self.morph,
            centerFlag=self.centerFlag,
            savePosType=self.savePosType,
            device=self.device,
        )
