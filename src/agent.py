import copy
import abc
import itertools
import warnings
import math
import numpy as np

import torch
import torch.nn as nn
import torch.nn.functional as F

from utils import *

warnings.simplefilter("error")


class HardEnvironment(object):
    """A class for the compact bundling of environment parameters"""

    def __init__(
        self,
        gravity=9.81,
        airFriction=0.1,
        ground=False,
        wind=None,
        device=torch.device("cpu"),
    ):
        self.gravity = gravity
        self.airFriction = airFriction
        self.ground = ground
        self.wind = wind
        self.device = device
        self.Fex = torch.zeros((2)).to(self.device)

    def setWind(self, wind):
        self.wind = wind

    def environmentForce(self, morph, state):
        """Calculate forces generated by the environment returns Vector Fenv asks a morphology and a state"""
        fair = -self.airFriction * state.speed
        fgravy = -self.gravity * morph.mass  # ground friction force
        fenv = fair
        fenv.y = fair.y + fgravy
        return fenv

    def windForce(self, morph):
        """Set wind strength"""
        xFwind = torch.ones((morph.noNodes)).to(self.device) * self.wind
        yFwind = torch.ones((morph.noNodes)).to(self.device)
        return SpaceList(xFwind, yFwind)

    def externalForce(self, morph, brain, us, inputLayer, noise):
        """Set external force"""
        if torch.all(us == 0):  ## Lissajous
            self.Fex = torch.zeros((2, morph.noNodes)).to(self.device)
        else:
            if brain:
                self.Fex = (brain(us.unsqueeze(0).to(torch.float32))).reshape(2, -1)
            else:  ## timeserires
                self.Fex = us * inputLayer
            if (morph.shape == "DoubleCircles") or (morph.shape == "MultiCircles"):
                self.Fex[:, -1] = 0
        if noise > 0:
            xNoise = (
                torch.normal(mean=0, std=1, size=xFex.shape).to(self.device) * noise
            )
            yNoise = (
                torch.normal(mean=0, std=1, size=yFex.shape).to(self.device) * noise
            )
            xFex += xNoise
            yFex += yNoise
            return SpaceList(xFex, yFex)
        return SpaceList(self.Fex)


class SoftEnvironment(HardEnvironment):

    def __init__(
        self,
        gravity=9.81,
        groundFriction=100,
        groundContact=10,
        airFriction=0.1,
        waterDensity=997,
        dragCoefficient=1,
        thrustCoefficient=1,
        ground=False,
        wind=None,
        device=torch.device("cpu"),
    ):
        super(SoftEnvironment, self).__init__(
            gravity=gravity,
            airFriction=airFriction,
            ground=ground,
            wind=wind,
            device=device,
        )
        self.groundFriction = groundFriction
        self.groundContact = groundContact
        self.waterDensity = waterDensity
        self.dragCoefficient = dragCoefficient
        self.thrustCoefficient = thrustCoefficient
        radius = 0.005
        self.area = np.pi * (radius**2) / 4
        self.volume = 3 / 4 * np.pi * (radius**3)

    def environmentForce(self, morph, state):
        """Calculate forces generated by the environment"""
        if self.ground:
            fair = -self.airFriction * state.speed
            fgravy = -self.gravity * morph.mass  # ground friction force
            fgroundy = self.groundContact * torch.exp(-self.groundContact * state.pos.y)
            fgroundx = torch.zeros_like(state.pos.x)
            fenv = fair + SpaceList(fgroundx, fgroundy + fgravy)
        return fenv


class Morphology(object):
    __metaclass__ = abc.ABCMeta
    """ An abstract class for the compact bundling of morphological parameters"""

    def __init__(
        self,
        initialPos,
        connections,
        noNodes,
        mass,
        environment,
        deltaInitialPos=None,
        seed=None,
        device=torch.device("cpu"),
        normalDrc=None,
    ):
        # init agent
        self.noNodes = noNodes  # the number of nodes the agent consists of
        self.environment = environment
        self.initialPos = initialPos
        self.connections = connections
        self.deltaInitialPos = deltaInitialPos
        self.seed = seed
        self.device = device
        self.normalDrc = normalDrc
        self.connections_tensor = torch.tensor(self.connections).to(self.device)
        self.fex_history = []

        # set initial masses
        if isCallable(mass):
            self.mass = mass((self.noNodes,))
        else:
            self.mass = mass * torch.ones((self.noNodes,)).to(self.device)

    def set_binaryNodes(self, binaryNodes):
        self.binaryNodes = binaryNodes

    def connectionParameterMatrix(self, parameter, mask=None):
        if mask is None:
            if isCallable(parameter):
                matrix = parameter((self.noNodes, self.noNodes)) * self.connections
                matrix = torch.tril(matrix) + torch.tril(matrix).T  # ensure symmetry
            else:
                matrix = (
                    parameter
                    * torch.ones((self.noNodes, self.noNodes))
                    * self.connections
                )
        else:
            if isCallable(parameter):
                matrix = parameter((self.noNodes, self.noNodes)) * self.connections
                matrix = (
                    torch.tril(matrix) + torch.tril(matrix).T * mask
                )  # ensure symmetry
            else:
                matrix = (
                    parameter
                    * torch.ones((self.noNodes, self.noNodes))
                    * self.connections
                    * mask
                )
        return matrix

    @abc.abstractmethod
    def _connectionForce(self, state, modulatedRestLength):
        """Return the force resulting of a connection"""

    def force(
        self,
        brain,
        state,
        modulatedRestLength,
        us,
        inputLayer,
        noise,
    ):
        """Calculate the force acting on the nodes"""
        fspring = self._connectionForce(state, modulatedRestLength)
        if (inputLayer.shape[1] == self.binaryNodes.shape[0]) or (
            inputLayer.shape[1] == self.binaryNodes.shape[0] * 2
        ):
            _inputLayer = inputLayer
        else:
            _inputLayer = inputLayer.view(inputLayer.shape[0], 2, -1)[:, 1]
        fex = self.environment.externalForce(self, brain, us, _inputLayer, noise)
        self.fex_history.append(fex.matrix)
        fall = fspring + fex
        if self.environment.ground:
            # environment force
            fenv = self.environment.environmentForce(self, state)
            fall = fall + fenv
        if self.environment.wind is not None:
            fwind = self.environment.windForce(self)
            fall = fall + fwind
        return fall

    def SymmetricMatrix(self, mat):
        if type(mat) == torch.Tensor:
            if not mat.is_cuda:
                mat = mat.to(self.device)
            mat = (mat + mat.T) / 2 * torch.tensor(self.connections).to(self.device)
            return mat
        else:
            mat = (mat + mat.T) / 2 * self.connections
            return torch.tensor(mat).to(self.device)


class SpringMorphology(Morphology):
    """Morphology consisting of linear springs"""

    def __init__(
        self,
        noNodes=20,
        mass=1,
        initialHeight=4,
        noNeighbours=3,
        environment=HardEnvironment(),
        shape="DoubleCircles",
        initSize=4,
        deltaPos=0.3,
        seed=None,
        noisedLength=False,
        device=torch.device("cpu"),
    ):

        self.initialHeight = initialHeight  # height of the agent
        self.noNeighbours = noNeighbours  # number of Neighbours
        self.environment = environment
        self.shape = shape
        self.device = device
        self.initSize = initSize
        self.eye = torch.eye(noNodes).to(self.device)
        normalDrc = None
        if shape == "CaterpillarRobot":
            initialPos = self.generateShapeCaterpillar(noNodes, initialHeight)
            connections, normalDrc = self.generateConnectionsRobot(noNodes)
            deltaInitialPos = None
        elif shape == "DoubleCircles":
            initialPos = self.generateShapeDoubleCircles(noNodes, self.initSize)
            connections = self.generateConnectionsDoubleCircles(noNodes)
        elif shape == "MultiCircles":
            initialPos = self.generateShapeMultiCircles(noNodes, self.initSize)
            connections = self.generateConnectionsMultiCircles(noNodes)
        if deltaPos is not None:
            deltaInitialPos = self.generateDeltaInitialPos(initialPos, deltaPos)
        else:
            deltaInitialPos = None
        super(SpringMorphology, self).__init__(
            initialPos,
            connections,
            noNodes=noNodes,
            mass=mass,
            environment=environment,
            deltaInitialPos=deltaInitialPos,
            seed=seed,
            device=device,
            normalDrc=normalDrc,
        )

        torch.manual_seed(seed)
        if noNodes < 50:
            self.spring, self.damping = self.setRandomPhysicalParams(
                1.0, 100.0, 0, 10.0
            )
        else:
            self.spring, self.damping = self.setRandomPhysicalParams(1.0, 100.0, 0, 5.0)

        # set rest length
        self.restLength = self.getRestLength(initialPos, connections, noisedLength)
        self.noComps = np.nonzero(np.triu(self.connections))[0].shape[0]

    def specifyInitSize(self, size):
        self.initSize = size

    def specifyPhysicalParams(self, spring, damping):
        self.spring = spring
        self.damping = damping

    def resetMorph(self, size, spring, damping, restLength=None):
        self.specifyInitSize(size)
        self.specifyPhysicalParams(spring, damping)
        if self.shape == "CaterpillarRobot":
            initialPos = self.generateShapeCaterpillar(self.noNodes, self.initialHeight)
            connections = self.generateConnectionsRobot(self.noNodes)
        elif self.shape == "DoubleCircles":
            initialPos = self.generateShapeDoubleCircles(self.noNodes, self.initSize)
            connections = self.generateConnectionsDoubleCircles(self.noNodes)
        elif self.shape == "MultiCircles":
            initialPos = self.generateShapeMultiCircles(self.noNodes, self.initSize)
            connections = self.generateConnectionsMultiCircles(self.noNodes)
        if restLength is not None:
            self.restLength = restLength
        super(SpringMorphology, self).__init__(
            initialPos,
            connections,
            noNodes=self.noNodes,
            mass=self.mass,
            environment=self.environment,
        )

    def setRandomPhysicalParams(self, springMin, springMax, dampingMin, dampingMax):
        spring = (springMax - springMin) * torch.rand(
            self.connections.shape[0], self.connections.shape[1]
        ) + springMin
        spring = (spring + spring.t()) / 2 * self.connections
        spring = self.SymmetricMatrix(spring)
        damping = (dampingMax - dampingMin) * torch.rand(
            self.connections.shape[0], self.connections.shape[1]
        ) + dampingMin
        damping = (damping + damping.t()) / 2 * self.connections
        damping = self.SymmetricMatrix(damping)
        return spring.to(self.device), damping.to(self.device)

    def setSamePhysicalParams(self, springVal, dampingVal):
        spring = (
            torch.full(
                (self.connections.shape[0], self.connections.shape[1]), springVal
            )
            * self.connections
        )
        damping = (
            torch.full(
                (self.connections.shape[0], self.connections.shape[1]), dampingVal
            )
            * self.connections
        )
        return spring.to(self.device), damping.to(self.device)

    def _connectionForce(self, state, modulatedRestLength):
        """Calculate the forces acting due to the springs, return x,y spring force"""
        difx, dify = state.pos.getDifference()
        difxy = torch.sqrt(difx**2 + dify**2 + 1e-16) + torch.eye(self.noNodes).to(
            self.device
        )  # Otherwise divide by zero
        # Normal Linear Spring Definition
        fConnectionx_spring = -torch.sum(
            self.spring * difx * (1 - modulatedRestLength / difxy), axis=1
        )
        fConnectiony_spring = -torch.sum(
            self.spring * dify * (1 - modulatedRestLength / difxy), axis=1
        )

        # damping forces
        difvx, difvy = state.speed.getDifference()
        fConnectionx_damping = -torch.sum(self.damping * difvx, axis=1)
        fConnectiony_damping = -torch.sum(self.damping * difvy, axis=1)

        fConnectionx = fConnectionx_spring + fConnectionx_damping
        fConnectiony = fConnectiony_spring + fConnectiony_damping

        return SpaceList(fConnectionx, fConnectiony)

    def getRestLength(self, initialPos, connections, noisedLength):
        difx, dify = initialPos.getDifference()
        restLength = torch.sqrt(difx**2 + dify**2 + 1e-16) * torch.tensor(
            connections
        ).to(self.device)
        if noisedLength:
            noiseMatrix = (torch.rand(self.noNodes, self.noNodes) * 0.4 + 0.8).to(
                self.device
            )
            restLength = restLength * noiseMatrix
        restLength = self.SymmetricMatrix(restLength)
        return restLength

    def generateShapeCaterpillar(self, noNodes, initialHeight):
        ## initialise nodes ##
        # compute initial x and y values (coordinates of the nodes)
        nodeIds = torch.arange(noNodes)
        xPos = torch.arange(noNodes) - noNodes / 2 + 0.5
        yPos = (
            torch.fmod(nodeIds + 1, 2)
            * (1 - torch.abs(2 * xPos / noNodes) ** 2)
            * self.initialHeight
        )
        initialPos = SpaceList(xPos.to(self.device), yPos.to(self.device))
        return initialPos

    def generateShapeDoubleCircles(self, noNodes, initSize, yShift=0):
        assert noNodes % 2 == 1
        nodeIds = torch.arange(noNodes).to(self.device)
        outerNodes = nodeIds[: int((noNodes - 1) / 2)]
        innerNodes = nodeIds[int((noNodes - 1) / 2) : noNodes]
        outerRadius = initSize / 2
        innerRadius = initSize / 4
        xPos0 = (
            torch.sin(
                nodeIds[: int((noNodes - 1) / 2)]
                * 2
                * np.pi
                / torch.max(nodeIds[: int((noNodes - 1) / 2)] + 1)
            )
            * outerRadius
        )
        xPos1 = (
            torch.sin(
                (nodeIds[: int((noNodes - 1) / 2)] + 0.5)
                * 2
                * np.pi
                / torch.max(nodeIds[: int((noNodes - 1) / 2)] + 1)
            )
            * innerRadius
        )
        xPos2 = torch.tensor([0]).to(self.device)
        xPos = torch.cat((xPos0, xPos1, xPos2))
        yPos0 = (
            torch.cos(
                nodeIds[: int((noNodes - 1) / 2)]
                * 2
                * np.pi
                / torch.max(nodeIds[: int((noNodes - 1) / 2)] + 1)
            )
            * outerRadius
        )
        yPos1 = (
            torch.cos(
                (nodeIds[: int((noNodes - 1) / 2)] + 0.5)
                * 2
                * np.pi
                / torch.max(nodeIds[: int((noNodes - 1) / 2)] + 1)
            )
            * innerRadius
        )
        yPos2 = torch.tensor([0]).to(self.device)
        yPos = torch.cat((yPos0, yPos1, yPos2)) + yShift
        initialPos = SpaceList(xPos.to(self.device), yPos.to(self.device))
        return initialPos

    def generateShapeMultiCircles(self, noNodes, initSize):
        assert noNodes % 2 == 1
        circleNum = int(math.sqrt(noNodes - 1) / 2)
        noNodesList = [(2 * (circleNum - i) - 1) * 4 for i in range(circleNum)]
        radiusList = [
            initSize / 2 / circleNum * (circleNum - i) for i in range(circleNum)
        ]
        nodeIds = torch.arange(noNodes).to(self.device)
        xPosList, yPosList = [], []
        firstIndex = 0
        for i in range(circleNum):
            nodes_in_circle = nodeIds[firstIndex : firstIndex + noNodesList[i]]
            if i % 2 == 0:
                _xPos = (
                    torch.sin(
                        nodes_in_circle * 2 * np.pi / torch.max(nodes_in_circle + 1)
                    )
                    * radiusList[i]
                )
                _yPos = (
                    torch.cos(
                        nodes_in_circle * 2 * np.pi / torch.max(nodes_in_circle + 1)
                    )
                    * radiusList[i]
                )
            else:
                _xPos = (
                    torch.sin(
                        (nodes_in_circle + 0.5)
                        * 2
                        * np.pi
                        / torch.max(nodes_in_circle + 1)
                    )
                    * radiusList[i]
                )
                _yPos = (
                    torch.cos(
                        (nodes_in_circle + 0.5)
                        * 2
                        * np.pi
                        / torch.max(nodes_in_circle + 1)
                    )
                    * radiusList[i]
                )
            xPosList.append(_xPos.to(self.device))
            yPosList.append(_yPos.to(self.device))
        xPosList.append(torch.tensor([0]).to(self.device))
        yPosList.append(torch.tensor([0]).to(self.device))
        xPos = torch.cat(xPosList)
        yPos = torch.cat(yPosList)
        initialPos = SpaceList(xPos.to(self.device), yPos.to(self.device))
        return initialPos

    def generateConnectionsRobot(self, noNodes):
        ## initialise connections ##
        # generate the connection matrix
        connections = np.zeros((noNodes, noNodes))
        for i in range(self.noNeighbours):
            connections[np.arange(1 + i, noNodes), np.arange(0, noNodes - 1 - i)] = (
                1  # connect adjacent nodes
            )
        connections += connections.T
        normalDrc = torch.zeros((noNodes, noNodes))
        if noNodes % 2 == 0:
            for i, j in itertools.product(
                range(normalDrc.shape[0]), range(normalDrc.shape[1])
            ):
                if i == j:
                    pass
                elif (
                    ((i % 2 == 0) and (j % 2 == 0))
                    or ((i == noNodes - 1) and (j == noNodes - 2))
                    or ((i == noNodes - 2) and (j == noNodes - 1))
                ):
                    normalDrc[i, j] = 1
                elif (
                    ((i % 2 == 1) and (j % 2 == 1))
                    or (i == 0 and j == 1)
                    or (i == 1 and j == 0)
                ):
                    normalDrc[i, j] = -1
        else:
            for i, j in itertools.product(
                range(normalDrc.shape[0]), range(normalDrc.shape[1])
            ):
                if i == j:
                    pass
                elif (i % 2 == 0) and (j % 2 == 0):
                    normalDrc[i, j] = 1
                elif (
                    ((i % 2 == 1) and (j % 2 == 1))
                    or (i == 0 and j == 1)
                    or (i == 1 and j == 0)
                    or ((i == noNodes - 1) and (j == noNodes - 2))
                    or ((i == noNodes - 2) and (j == noNodes - 1))
                ):
                    normalDrc[i, j] = -1
        return connections, normalDrc

    def generateConnectionsDoubleCircles(self, noNodes):
        ## initialise connections ##
        # generate the connection matrix
        assert noNodes % 2 == 1
        connections = np.zeros((noNodes, noNodes))
        for i in range(int((noNodes - 1) / 2)):
            if i == 0:
                connections[i, int((noNodes - 1) / 2) + i] = connections[
                    i, noNodes - 2
                ] = 1
            else:
                connections[i, int((noNodes - 1) / 2) + i - 1] = connections[
                    i, int((noNodes - 1) / 2) + i
                ] = 1
        for i in range(int((noNodes - 1) / 2), noNodes - 1):
            if i == int((noNodes - 1) / 2):
                connections[i, i + 1] = connections[i, noNodes - 2] = connections[
                    i, noNodes - 1
                ] = 1
            else:
                connections[i, i + 1] = connections[i, noNodes - 1] = 1
        connections += connections.T
        return connections

    def generateConnectionsMultiCircles(self, noNodes):
        ## initialise connections ##
        # generate the connection matrix
        circleNum = int(math.sqrt(noNodes - 1) / 2)
        noNodesList = [(2 * (circleNum - i) - 1) * 4 for i in range(circleNum)]
        connections = np.zeros((noNodes, noNodes))
        _step = int((circleNum * 2 - 4) / 2)

        for i in range(circleNum - 1):
            if i == 0:
                outerIndexes = [j for j in range(noNodesList[i])]
            else:
                outerIndexes = [j + sum(noNodesList[:i]) for j in range(noNodesList[i])]
            innerIndexes = [
                j + sum(noNodesList[: i + 1]) for j in range(noNodesList[i + 1])
            ]
            _currentOuterNode, _currentInnerNode = outerIndexes[0], innerIndexes[0]
            if i != 0:
                for j in outerIndexes[:-1]:
                    connections[j, j + 1] = 1
                connections[outerIndexes[-1], outerIndexes[0]] = 1
            for _ in range(4):
                for j in range(_step):
                    connections[_currentOuterNode + j, _currentInnerNode + j] = 1
                _currentOuterNode += _step
                _currentInnerNode += _step
                for j in range(3):
                    connections[_currentOuterNode + j, _currentInnerNode] = 1
                _currentOuterNode += 3
                _currentInnerNode += 1
                for j in range(_step):
                    connections[_currentOuterNode + j, _currentInnerNode + j] = 1
                _currentOuterNode += _step
                _currentInnerNode += _step
            _step -= 1
        outerIndexes = [j + sum(noNodesList[:-1]) for j in range(noNodesList[-1])]
        for j in outerIndexes[:-1]:
            connections[j, j + 1] = 1
            connections[j, -1] = 1
        connections[outerIndexes[-1], outerIndexes[0]] = connections[
            outerIndexes[-1], -1
        ] = 1

        connections += connections.T
        connections = np.where(connections > 1, 1, connections)
        return connections

    def generateDeltaInitialPos(self, initialPos, deltaPos):
        if self.shape == "DoubleCircles":
            deltaMatrix = SpaceList(deltaPos)
            deltaInitialPos = initialPos.copy() + deltaMatrix
        elif self.shape == "MultiCircles":
            deltaMatrix = SpaceList(deltaPos)
            deltaInitialPos = initialPos.copy() + deltaMatrix
        return deltaInitialPos

    @staticmethod
    def maxTimeStep(maximumSpringConstant, minimumWeight):

        return np.pi / 5 * np.sqrt(1.0 * minimumWeight / maximumSpringConstant)

    @staticmethod
    def checkConfig(maximumSpringConstant, minimumWeight, timeStep):

        assert timeStep <= SpringMorphology.maxTimeStep(
            maximumSpringConstant, minimumWeight
        )


class AgentState(object):
    """A class for the compact bundling of the state of an Agent"""

    def __init__(
        self,
        currentTime=0,
        morph=None,
        copyState=0,
        centerFlag=False,
        savePosType="tensor",
        device=torch.device("cpu"),
    ):
        self.centerFlag = centerFlag
        self.device = device
        if copyState == 0:
            self.currentTime = currentTime
            self.pos = SpaceList.copy(morph.initialPos)
            self.shape = self.pos.shape
            self.speed = SpaceList(torch.zeros((self.shape)).to(self.device))
            self.acceleration = SpaceList(torch.zeros((self.shape)).to(self.device))
        elif copyState == 1:
            self.currentTime = currentTime
            self.pos = SpaceList.copy(morph.deltaInitialPos)
            self.shape = self.pos.shape
            self.speed = SpaceList(torch.zeros((self.shape)).to(self.device))
            self.acceleration = SpaceList(torch.zeros((self.shape)).to(self.device))
        else:
            self.currentTime = copyState.currentTime
            self.pos = copyState.pos.copy()
            self.shape = self.pos.shape
            self.speed = copyState.speed.copy()
            self.acceleration = SpaceList(torch.zeros((self.shape)).to(self.device))
        self.savePosType = savePosType
        self.movableNodes_history = []
        self.pos_history = []
        self.centerNode_history = []
        self.vel_history = []

        self.movableNodes = None

    def resetState(self, morph, keepTime=False, keepStates=False):
        if not keepTime:
            self.currentTime = 0.0
        if morph is not None:
            if keepStates:
                pass
            else:
                self.pos = SpaceList.copy(morph.initialPos)
                self.shape = self.pos.shape
                self.speed = SpaceList(torch.zeros((self.shape)).to(self.device))
                self.acceleration = SpaceList(torch.zeros((self.shape)).to(self.device))
        self.movableNodes_history = []
        self.pos_history = []
        self.centerNode_history = []
        self.vel_history = []

    def resetSavePosType(self, savePosType):
        self.savePosType = savePosType
        self.movableNodes_history = []
        self.pos_history = []
        self.centerNode_history = []
        self.vel_history = []

    def copy(self):
        """Create a copy of the current state so this copy will not change"""
        return AgentState(
            copyState=self,
            centerFlag=self.centerFlag,
            savePosType=self.savePosType,
            device=self.device,
        )

    def changeState(self, addt, addpos, addspeed, ground=False, acceleration=None):
        """Add time and add Vectors to the current positions and speed"""
        for inputValue in [addpos, addspeed]:
            assert self.shape == np.shape(inputValue), "wrong shape of input arguments"
        self.pos += addpos
        self.speed += addspeed
        self.currentTime = round(self.currentTime + addt, 2)
        if ground:
            self.pos.ground(self.speed)

    def addPos(self, addt, addpos, ground=False):
        assert self.shape == np.shape(addpos), "wrong shape of input arguments"
        self.pos += addpos
        self.currentTime = round(self.currentTime + addt, 2)
        if ground:
            self.pos.ground(self.speed)

    def addSpeed(self, addspeed, ground=False):
        assert self.shape == np.shape(addspeed), "wrong shape of input arguments"
        self.speed += addspeed
        if ground:
            self.pos.ground(self.speed)

    def addAcceleration(self, acceleration, ground=False):
        assert self.shape == np.shape(acceleration), "wrong shape of input arguments"
        self.acceleration = acceleration
        if ground:
            self.pos.ground(self.speed)

    def savePos(self, tau, simStep):
        if self.savePosType == "tensor":
            if simStep % tau == tau - 1:
                movableNodesPos = torch.stack(
                    [
                        self.pos.x.gather(0, self.movableNodes),
                        self.pos.y.gather(0, self.movableNodes),
                    ],
                    dim=0,
                )
                self.movableNodes_history.append(movableNodesPos)
            if self.centerFlag:
                centerNodePos = torch.stack(
                    [
                        self.pos.x[-1],
                        self.pos.y[-1],
                        self.speed.x[-1],
                        self.speed.y[-1],
                    ],
                    dim=0,
                )
                self.centerNode_history.append(centerNodePos)
            if self.vel_history is not None:
                allNodesPos = torch.stack([self.pos.x, self.pos.y], dim=0)
                self.pos_history.append(allNodesPos)
                allNodesVel = torch.stack([self.speed.x, self.speed.y], dim=0)
                self.vel_history.append(allNodesVel)

        else:
            raise NotImplementedError

    def resetCurrentTime(self):
        self.currentTime = 0


class Control(object):
    __metaclass__ = abc.ABCMeta
    """ An abstract class for the compact bundling of control parameters"""

    @abc.abstractmethod
    def modulationFactor(self, agentState, brain):
        """Must return array with modulation factors"""


class TimeControl(Control):
    __metaclass__ = abc.ABCMeta
    """ Abstract class with control signals only based on time """

    @abc.abstractmethod
    def modulationFactorTime(self, time, brain):
        """Must return array with modulation factors"""

    def modulationFactor(self, agentState, brain):
        return self.modulationFactorTime(agentState.currentTime, brain)


class NoControl(TimeControl):
    """Specific instance of Control Class"""

    def __init__(self, morph, simTime, simTimeStep, tau, device=torch.device("cpu")):
        super(NoControl, self).__init__()
        self.simTimeStep = simTimeStep
        self.simulLen = round(simTime / simTimeStep)
        self.trainLen = round(self.simulLen * 3 / 5 / tau) * tau
        self.testLen = round(self.simulLen / 5 / tau) * tau
        self.washoutLen = self.simulLen - self.trainLen - self.testLen
        self.tau = tau
        self.charSize, self.timeScale = None, None
        self.device = device

    def setExpandedNARMA(
        self,
        tau,
        delay,
        seed,
        inputScale=None,
        simTime=None,
    ):
        self.inputScale = inputScale
        np.random.seed(seed)
        if simTime is not None:
            self.setSimTime(simTime, self.simTimeStep, tau)
        original_us_length = int(self.simulLen // tau)
        try:
            us, ys = generate_expandedNARMA_target(
                original_us_length, delay, rseed=seed
            )
        except RuntimeWarning:
            for j in range(1, 10000):
                try:
                    us, ys = generate_expandedNARMA_target(
                        original_us_length, delay, rseed=seed + j
                    )
                except RuntimeWarning:
                    continue
        us_ = us.reshape([-1, 1])
        self.us_original = us_
        us_multi_ = np.concatenate([us_] * tau, 1)
        us_multi = np.ravel(us_multi_)
        self.us = (
            torch.tensor(us_multi[-self.simulLen :]).to(self.device) * self.inputScale
        )
        self.target = torch.tensor(ys).to(self.device)

    def setMemoryTask(
        self, tau, delay, seed, inputScale=None, simTime=None, cumulative=False
    ):
        self.inputScale = inputScale
        np.random.seed(seed)
        if simTime is not None:
            self.setSimTime(simTime, self.simTimeStep, tau)
        original_us_length = int(self.simulLen // tau)
        try:
            us, ys = generate_delay(
                original_us_length, delay, rseed=seed, cumulative=cumulative
            )
        except RuntimeWarning:
            for j in range(1, 10000):
                try:
                    us, ys = generate_delay(
                        original_us_length, delay, rseed=seed + j, cumulative=cumulative
                    )
                except RuntimeWarning:
                    continue
        us_ = us.reshape([-1, 1])
        self.us_original = us_
        us_multi_ = np.concatenate([us_] * tau, 1)
        us_multi = np.ravel(us_multi_)
        self.us = (
            torch.tensor(us_multi[-self.simulLen :]).to(self.device) * self.inputScale
        )
        self.target = torch.tensor(ys).to(self.device)

    def setSimTime(self, simTime, simTimeStep, tau):
        self.simTimeStep = simTimeStep
        self.tau = tau
        self.simulLen = round(simTime / self.simTimeStep)
        self.trainLen = round(self.simulLen * 3 / 5 / self.tau) * self.tau
        self.testLen = round(self.simulLen / 5 / self.tau) * self.tau
        self.washoutLen = self.simulLen - self.trainLen - self.testLen

    def set_for_limitcycle(self, morph, inputScale=None, us=None):
        self.inputScale = inputScale
        if us is not None:
            self.us = us * self.inputScale
        else:
            self.us = torch.zeros(morph.noNodes * 2).to(self.device) * self.inputScale

    def modulationFactorTime(self, time, brain):
        """Return rest length modulation factor"""
        return 1


class SineControl(NoControl):
    """Specific instance of Control Class with sines, works on spring morphologies"""

    uniform2pi = lambda shape: torch.distributions.Uniform(0, 2 * np.pi).sample(shape)

    def __init__(
        self,
        morph,
        simTime,
        simTimeStep,
        tau,
        device=torch.device("cpu"),
        amplitude=0.2,
        phase=uniform2pi,
        omega=2 * np.pi,
        generatorNum=1,
    ):
        super(SineControl, self).__init__(morph, simTime, simTimeStep, tau, device)

        ## initialise modulation paramters ##
        if generatorNum[0] < 0:
            generatorMask = None
        else:
            generatorMask = torch.zeros((morph.noNodes, morph.noNodes))
            _connections = np.triu(morph.connections)
            compNum = 0
            for i, j in itertools.product(
                range(_connections.shape[0]), range(_connections.shape[1])
            ):
                if _connections[i, j]:
                    if compNum in generatorNum:
                        generatorMask[i, j] = 2
                    compNum += 1
            generatorMask = morph.SymmetricMatrix(generatorMask)
        self.amplitude = morph.connectionParameterMatrix(amplitude, generatorMask)
        self.phase = morph.connectionParameterMatrix(phase, generatorMask)
        self.omega = morph.connectionParameterMatrix(omega, generatorMask)

        self.feedback = False

    def initFeedbackLoop(
        self, noNodes, stateDim, randomInit=False, flatten=False, std=0.01
    ):
        if randomInit:
            self.feedback = False
            self.feedbackFactor = torch.zeros((noNodes, noNodes), dtype=torch.float64)
            self.feedbackLayers = torch.normal(
                mean=0, std=std, size=(noNodes, noNodes, stateDim), dtype=torch.float64
            )
        else:
            self.feedback = True
            self.feedbackFactor = torch.zeros((noNodes, noNodes), dtype=torch.float64)
            self.feedbackLayers = torch.zeros(
                (noNodes, noNodes, stateDim), dtype=torch.float64
            )

    def removeGenerator(self, x, y):
        self.amplitude[x, y], self.amplitude[y, x] = 0, 0
        self.phase[x, y], self.phase[y, x] = 0, 0
        self.omega[x, y], self.omega[y, x] = 0, 0

    def setFeedbackLayers(self, x, y, W, removeGenerator=True):
        if removeGenerator:
            self.removeGenerator(x, y)
        self.feedbackLayers[x, y] = W
        self.feedbackLayers[y, x] = W

    def setFeedbackFactor(self, states):
        if self.feedbackLayers.shape[-1] == states.shape[0]:
            self.feedbackFactor = torch.matmul(self.feedbackLayers, states).squeeze()
        else:
            self.feedbackFactor = torch.matmul(states, self.feedbackLayers).squeeze()

    def modulationFactorTime(self, time, brain):
        """Return rest length modulation factor"""
        if self.feedback:
            return (
                1
                + self.amplitude * torch.sin(self.omega * time + self.phase)
                + self.feedbackFactor
            )
        else:
            return 1 + self.amplitude * torch.sin(self.omega * time + self.phase)


class FreeControl(NoControl):
    """Specific instance of Control Class"""

    uniform2pi = lambda shape: torch.distributions.Uniform(0, 2 * np.pi).sample(shape)

    def __init__(
        self,
        morph,
        simTime,
        simTimeStep,
        tau,
        device=torch.device("cpu"),
        amplitude=0.2,
        phase=uniform2pi,
        omega=2 * np.pi,
        generatorNum=1,
    ):
        super(FreeControl, self).__init__(morph, simTime, simTimeStep, tau, device)

        ## initialise modulation paramters ##
        if generatorNum[0] < 0:
            generatorMask = None
        else:
            generatorMask = torch.zeros((morph.noNodes, morph.noNodes))
            for num in generatorNum:
                generatorIndex = torch.nonzero(torch.from_numpy(morph.connections))[
                    num, :
                ]
                generatorMask[generatorIndex[0], generatorIndex[1]] = generatorMask[
                    generatorIndex[1], generatorIndex[0]
                ] = 1
        self.amplitude = morph.connectionParameterMatrix(amplitude, generatorMask)
        self.phase = morph.connectionParameterMatrix(phase, generatorMask)
        self.omega = morph.connectionParameterMatrix(omega, generatorMask)
        self.morph = morph
        self.generatorMask = generatorMask

        self.base_omega = copy.copy(np.matrix([omega]))

    def modulationFactorTime(self, time, brain):
        """Return rest length modulation factor"""
        newLengths = brain(self.us.unsqueeze(0).to(torch.float32) * 20)
        modulationFac = torch.zeros((self.morph.noNodes, self.morph.noNodes))
        for i, (x, y) in enumerate(
            zip(
                np.nonzero(self.morph.connections)[0],
                np.nonzero(self.morph.connections)[1],
            )
        ):
            modulationFac[x][y] = newLengths[0, i]
        modulationFac = (modulationFac + modulationFac.T) / 2
        if self.generatorMask is not None:
            modulationFac = modulationFac * self.generatorMask
        return 1 + self.amplitude * torch.sin(modulationFac)


class BrainMLP(nn.Module):
    def __init__(self, inputDim, outputDim):
        super(BrainMLP, self).__init__()
        if inputDim > 100:
            self.fc1 = nn.Linear(inputDim, inputDim * 2)
            self.fc2 = nn.Linear(inputDim * 2, inputDim)
            self.fc3 = nn.Linear(inputDim, outputDim)
            torch.nn.init.xavier_normal_(self.fc1.weight, gain=1)
            torch.nn.init.xavier_normal_(self.fc2.weight, gain=1)
            torch.nn.init.xavier_normal_(self.fc3.weight, gain=1)
        else:
            self.fc1 = nn.Linear(inputDim, 128)
            self.fc2 = nn.Linear(128, 128)
            self.fc3 = nn.Linear(128, outputDim)
            torch.nn.init.xavier_normal_(self.fc1.weight, gain=2.7)
            torch.nn.init.xavier_normal_(self.fc2.weight, gain=2.7)
            torch.nn.init.xavier_normal_(self.fc3.weight, gain=2.7)

    def forward(self, x):
        x = F.relu(self.fc1(x))
        x = F.relu(self.fc2(x))
        x = self.fc3(x)
        return x


class BrainCNN(nn.Module):
    def __init__(self, outputDim):
        super(BrainCNN, self).__init__()
        self.conv1 = nn.Conv2d(1, 16, 3)
        self.conv2 = nn.Conv2d(16, 32, 3)
        self.pool = nn.MaxPool2d(2, stride=2)
        self.fc = nn.Linear(32 * 5 * 5, outputDim)
        torch.nn.init.xavier_normal_(self.fc.weight, gain=1)

    def forward(self, x):
        x = F.relu(self.conv1(x))
        x = self.pool(x)
        x = F.relu(self.conv2(x))
        x = self.pool(x)
        x = x.view(-1, 32 * 5 * 5)
        x = self.fc(x)
        return x


class Agent(object):
    """A class for the compact bundling of the morphology, control system and state of the agent"""

    def __init__(
        self,
        morph,
        control,
        state=None,
        deltaPos=None,
        seed=None,
        readoutDim=1,
        centerFlag=False,
        centralPointOutput=False,
        savePosType="tensor",
        pixTOnode=True,
        pixXpix=25,
        bias=False,
        brain="LIL",
        closedloop=False,
        noise=0,
        device=torch.device("cpu"),
    ):
        self.morph = morph
        self.control = control
        self.centerFlag = centerFlag
        self.savePosType = savePosType
        if state is not None:
            self.state = state
        elif deltaPos is not None:
            self.state = AgentState(
                currentTime=0,
                morph=morph,
                copyState=1,
                centerFlag=self.centerFlag,
                savePosType=self.savePosType,
                device=device,
            )
        else:
            self.state = AgentState(
                currentTime=0,
                morph=morph,
                centerFlag=self.centerFlag,
                savePosType=self.savePosType,
                device=device,
            )
        self.seed = seed
        self.brain = None
        self.device = device
        self.optimizer_ridge = Ridge_opt(beta=1e-9, device=self.device)
        self.preSimStep = None
        if self.morph.shape == "DoubleCircles":
            self.fixedNodes = [i for i in range(int((self.morph.noNodes - 1) / 2))]
        elif self.morph.shape == "MultiCircles":
            circleNum = int(math.sqrt(self.morph.noNodes - 1) / 2)
            self.fixedNodes = [i for i in range((2 * circleNum - 1) * 4)]
        elif self.morph.shape == "CaterpillarRobot":
            self.fixedNodes = []
        del_list = lambda items, indexes: [
            item for index, item in enumerate(items) if index not in indexes
        ]
        allNodes = [i for i in range(self.morph.noNodes)]
        self.movableNodes = torch.tensor(del_list(allNodes, self.fixedNodes)).to(
            self.device
        )
        self.state.movableNodes = self.movableNodes
        self.centralPointOutput = centralPointOutput
        if centralPointOutput:
            self.reservoirStatesDim = 2
        else:
            self.reservoirStatesDim = self.movableNodes.shape[0] * 2
        self.binaryNodes = torch.tensor(
            [0 if i in self.fixedNodes else 1 for i in range(self.morph.noNodes)]
        ).to(self.device)
        self.morph.set_binaryNodes(self.binaryNodes)
        self.closedloop = closedloop
        self.noise = noise
        torch.manual_seed(seed)
        if pixTOnode:
            if brain == "MLP":
                if self.closedloop:
                    self.inputLayer = torch.normal(
                        mean=0,
                        std=1,
                        size=(self.morph.noComps, self.morph.noNodes * 2),
                        dtype=torch.float64,
                    ).to(self.device)
                    self.brain = BrainMLP(
                        self.morph.noComps * 2, self.morph.noComps
                    ).to(self.device)
                else:
                    self.inputLayer = torch.normal(
                        mean=0,
                        std=1,
                        size=(self.morph.noNodes * 2, self.morph.noNodes * 2),
                        dtype=torch.float64,
                    ).to(self.device)
                    self.brain = BrainMLP(1, self.morph.noNodes * 2).to(self.device)
            elif brain == "CNN":
                self.inputLayer = torch.normal(
                    mean=0,
                    std=1,
                    size=(self.morph.noComps, self.morph.noNodes * 2),
                    dtype=torch.float64,
                ).to(self.device)
                self.brain = BrainCNN(self.morph.noComps).to(self.device)
            elif bias:
                self.inputLayer = torch.normal(
                    mean=0,
                    std=1,
                    size=(self.morph.noNodes * 2, self.morph.noNodes * 2),
                    dtype=torch.float64,
                ).to(self.device)
            else:  ## timeseries
                self.inputLayer = torch.normal(
                    mean=0, std=1, size=(2, self.morph.noNodes), dtype=torch.float64
                ).to(self.device)
        else:
            if brain == "MLP":
                self.inputLayer = torch.normal(
                    mean=0,
                    std=0.01,
                    size=(self.morph.noNodes * 2, self.morph.noNodes * 2),
                ).to(self.device)
                self.brain = BrainMLP(pixXpix, self.morph.noNodes * 2).to(self.device)
            elif brain == "CNN":
                self.inputLayer = torch.normal(
                    mean=0,
                    std=0.01,
                    size=(self.morph.noNodes * 2, self.morph.noNodes * 2),
                ).to(self.device)
                self.brain = BrainCNN(self.morph.noNodes * 2).to(self.device)
            else:  ## MNIST
                self.inputLayer = torch.normal(
                    mean=0, std=0.01, size=(pixXpix, self.morph.noNodes * 2)
                ).to(self.device)
        self.readoutDim = readoutDim
        torch.manual_seed(seed)
        self.readoutLayer = torch.normal(
            mean=0,
            std=1,
            size=(self.reservoirStatesDim + 1, readoutDim),
            dtype=torch.float64,
        ).to(self.device)

    def resetAgent(self, morph=None, keepTime=False, keepStates=False):
        if keepStates:
            assert morph is not None
        if not keepTime:
            self.state.resetCurrentTime()
        self.resetOptimizer()
        if morph is not None:
            self.morph = morph
        self.state.resetState(morph, keepTime=keepTime, keepStates=keepStates)
        self.morph.fex_history = []

    def resetOptimizer(self):
        self.optimizer_ridge = Ridge_opt(beta=1e-9, device=self.device)

    def setdeltaPos(self, deltaPos):
        if self.morph.shape == "MultiCircles":
            initialPos = self.morph.generateShapeMultiCircles(
                self.morph.noNodes, self.morph.initSize
            )
            self.morph.deltaInitialPos = self.morph.generateDeltaInitialPos(
                initialPos, deltaPos
            )
            self.state = AgentState(
                currentTime=0,
                morph=self.morph,
                copyState=1,
                centerFlag=self.centerFlag,
                savePosType=self.savePosType,
                device=self.device,
            )
            self.state.movableNodes = self.movableNodes
        elif self.morph.shape == "DoubleCircles":
            initialPos = self.morph.generateShapeDoubleCircles(
                self.morph.noNodes, self.morph.initSize
            )
            self.morph.deltaInitialPos = self.morph.generateDeltaInitialPos(
                initialPos, deltaPos
            )
            self.state = AgentState(
                currentTime=0,
                morph=self.morph,
                copyState=1,
                centerFlag=self.centerFlag,
                savePosType=self.savePosType,
                device=self.device,
            )
            self.state.movableNodes = self.movableNodes

    def computeForces(self, simStep):
        ## Forces
        # modulated rest lengths
        modFactor = self.control.modulationFactor(self.state, self.brain)
        if type(modFactor) != int:
            modFactor = modFactor.to(self.device)
        modulatedRestLength = self.morph.restLength * modFactor
        if self.control.us.shape[0] == self.control.simulLen:
            f = self.morph.force(
                self.brain,
                self.state,
                modulatedRestLength,
                self.control.us[simStep],
                self.inputLayer,
                self.noise,
            )
        else:
            f = self.morph.force(
                self.brain,
                self.state,
                modulatedRestLength,
                self.control.us,
                self.inputLayer,
                self.noise,
            )
        return f

    def computeAcceleration(self, simStep):
        """Compute acceleration, returns Acceleration Vector"""
        f = self.computeForces(simStep)
        a = f / self.morph.mass
        return a

    def getVelocity(self):
        """Return a list of x and y velocity"""
        return self.state.speed

    def getState(self):
        return self.state.copy()

    def changeState(self, timeStep, V, A):
        """Change the time and positions based on time derivatives"""

        posChange = timeStep * V
        speedChange = A * timeStep
        self.state.changeState(
            timeStep, posChange, speedChange, self.morph.environment.ground
        )
        self.state.savePos()

    def changeStateVerlet(self, timeStep, V, Aold, tau=10, noise=0, impulsenoise=None):
        simStep = round(self.state.currentTime * 100)

        if noise != 0:
            shape = np.shape(V.matrix)
            posNoise = 1 + np.random.standard_normal(shape) * noise
            speedNoise = 1 + np.random.standard_normal(shape) * noise

        posChange = timeStep * V + (timeStep * timeStep) * Aold / 2
        posChange.x = posChange.x * self.binaryNodes
        posChange.y = posChange.y * self.binaryNodes

        if noise != 0:
            posChange *= posNoise
        self.state.addPos(timeStep, posChange, self.morph.environment.ground)
        self.state.savePos(tau, simStep)
        Anew = self.computeAcceleration(simStep)
        self.state.addAcceleration(Anew, self.morph.environment.ground)

        if impulsenoise is not None:
            Anew = Anew + SpaceList(impulsenoise)

        # then Force calculation
        # then Speed update
        speedChange = timeStep * (Aold + Anew) / 2
        speedChange.x = speedChange.x * self.binaryNodes
        speedChange.y = speedChange.y * self.binaryNodes
        if noise != 0:
            speedChange *= speedNoise
        self.state.addSpeed(speedChange, self.morph.environment.ground)

        return Anew

    def addData(self, tau, simStep):
        control = self.control
        if self.centralPointOutput:
            reservoirStates = torch.cat(
                (self.state.pos.x[-1].unsqueeze(0), self.state.pos.y[-1].unsqueeze(0))
            )
        else:
            reservoirStates = torch.cat(
                (
                    torch.flatten(self.state.pos.x).gather(0, self.movableNodes),
                    torch.flatten(self.state.pos.y).gather(0, self.movableNodes),
                )
            )
        if simStep < control.washoutLen:
            pass
        elif (
            (simStep >= control.washoutLen)
            and (simStep < control.washoutLen + control.trainLen)
            and (simStep > self.preSimStep)
        ):
            self.optimizer_ridge.add_data(
                reservoirStates,
                control.target[round((self.state.currentTime * 100 - 1) // tau)],
            )
        elif (simStep >= control.washoutLen + control.trainLen) and (
            simStep > self.preSimStep
        ):
            self.optimizer_ridge.add_data(
                reservoirStates,
                control.target[round((self.state.currentTime * 100 - 1) // tau)],
                test=True,
            )
        self.preSimStep = simStep

    def printState(self):

        state = self.state
        meanSpeed = torch.mean(state.speed.x).to(self.device)
        time = state.currentTime
        if self.morph.environment.wind is None:
            if len(self.movableNodes) == self.morph.noNodes:
                stateDescription = "speed: {:.2f}".format(meanSpeed.item())
            else:
                stateDescription = f"current time: {time}"
        else:
            if self.morph.environment.wind > 0:
                arrow = (
                    "-"
                    * int(
                        self.morph.environment.wind / 15 / self.control.inputScale * 10
                    )
                    + ">"
                )

            elif self.morph.environment.wind < 0:
                arrow = "<" + "-" * int(
                    -self.morph.environment.wind / 15 / self.control.inputScale * 10
                )
            else:
                arrow = ""
            if len(self.movableNodes) == self.morph.noNodes:
                stateDescription = (
                    "speed: {:.2f}".format(meanSpeed.item())
                    + f"\nwind: {round(self.morph.environment.wind/15, 2)}\n{arrow}"
                )
            else:
                stateDescription = (
                    f"wind: {round(self.morph.environment.wind/15, 2)}\n{arrow}"
                )
        return stateDescription

    def _getAgentPos2D(self):
        """Get the x and y coordinates of the nodes and the connections matrix"""
        return self.state.pos.x, self.state.pos.y, self.morph.connections

    def reset(self):

        self.state = AgentState(
            0,
            self.morph,
            centerFlag=self.centerFlag,
            savePosType=self.savePosType,
            device=self.device,
        )
